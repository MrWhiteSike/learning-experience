package tableapi;

public class TableTest3_Join {
    public static void main(String[] args) {
        /**
         *  JOINs
         *
         *  Flink SQL支持动态表上复杂而灵活的 JOIN 操作。有几种不同类型的 JOIN 可用于解释可能需要的各种各样的语义查询。
         *  默认情况下，联接的顺序不会优化。表按照FROM子句中指定的顺序连接。
         *  您可以调整联接查询的性能，方法是首先列出更新频率最低的表，最后列出更新频率最高的表。
         *  请确保以不产生交叉连接（笛卡尔乘积）的顺序指定表，这是不受支持的，并且会导致查询失败。
         *
         *
         *  Regular Joins
         *  常规JOIN是最通用的联接类型，其中任何新记录或对联接任一侧的更改都是可见的，并影响整个联接结果。
         *  例如，如果左侧有一个新记录，则当产品id等于时，它将与右侧所有以前和将来的记录连接。
         *
         *  对于流式查询，常规JOIN的语法是最灵活的，并且允许任何类型的更新（插入、更新、删除）输入表。
         *  然而，此操作具有重要的操作含义：它需要将联接输入的两侧永远保存在Flink状态中。
         *  因此，计算查询结果所需的状态可能会无限增长，这取决于所有输入表和中间联接结果的不同输入行的数量。
         *  您可以为查询配置提供适当的生存时间（TTL），以防止状态大小过大。请注意，这可能会影响查询结果的正确性。有关详细信息，请参阅查询配置。
         *
         *  对于流式查询，计算查询结果所需的状态可能会无限增长，这取决于聚合的类型和不同分组键的数量。
         *  请提供空闲状态保持时间（TTL），以防止状态大小过大。有关详细信息，请参阅空闲状态保留时间。
         *
         *
         * INNER Equi-JOIN
         * 返回受联接条件限制的简单笛卡尔乘积。目前，只支持相等联接，即至少有一个带有相等谓词的连接条件的联接。不支持任意的交叉连接或θ连接。
         *
         * OUTER Equi-JOIN
         * 返回合格笛卡尔乘积中的所有行（即，通过其联接条件的所有组合行），以及联接条件与其他表的任何行不匹配的外部表中每行的一个副本。
         * Flink支持LEFT、RIGHT和FULL外部联接。目前，只支持相等联接，即至少有一个带有相等谓词的连接条件的联接。不支持任意的交叉连接或θ连接。
         *
         * Interval Joins
         * 返回受联接条件和时间约束限制的简单笛卡尔乘积。Interval Join 至少需要一个等值联接谓词和一个限定两边时间的联接条件。
         * 两个适当的范围谓词可以这样定义条件（<，<=，>=，>）、一个BETWEEN谓词或一个比较两个输入表的相同类型（即处理时间或事件时间）的时间属性的单一相等谓词。
         * 注意：对于流式查询，与常规联接相比，interval联接仅支持具有时间属性的append-only表。
         * 由于时间属性是准单调递增的，Flink可以在不影响结果正确性的情况下从其状态中删除旧值。
         *
         *
         * Temporal Joins
         * 时态表是随着时间的推移而演变的表，在Flink中也称为动态表。
         * 时态表中的行与一个或多个时态周期相关联，并且所有Flink表都是时态的（动态的）。
         * 时态表包含一个或多个版本化的表快照，它可以是跟踪更改的更改历史表（例如，数据库更改日志，包含所有快照），
         * 也可以是具体化更改的更改维度表（例如包含最新快照的数据库表）。
         *
         * Event Time Temporal Join
         * 事件时间临时联接允许针对版本控制的表进行联接。这意味着可以使用不断变化的元数据来丰富表，并在某个时间点检索其值。
         * 时态联接采用任意表（左输入/探测站点），并将每一行与版本化表中相应行的相关版本（右输入/构建侧）相关联。
         * Flink使用FOR SYSTEM_TIME AS of的SQL语法来执行SQL:2011标准中的此操作。时态联接的语法如下所示：
         *
         * SELECT [column_list]
         * FROM table1 [AS <alias1>]
         * [LEFT] JOIN table2 FOR SYSTEM_TIME AS OF table1.{ proctime | rowtime } [AS <alias2>]
         * ON table1.column-name1 = table2.column-name1
         *
         * 使用事件时间属性（即rowtime属性），可以检索键的值，就像过去某个时候一样。这允许在一个共同的时间点连接两个表。
         * 版本表将存储自上次水印以来的所有版本（按时间标识）。
         *
         * 注意：事件时间-Temporal Join由来自左侧和右侧的水印触发；请确保连接的两边都正确设置了水印。
         * 时态表联接不能定义联接记录的时间窗口。
         * 探测端的记录总是在时间属性指定的时间与构建端的版本连接。因此，构建端的行可能是任意旧的。
         * 随着时间的推移，不再需要的记录版本（对于给定的主键）将从状态中删除。
         *
         * Processing Time Temporal Join
         * 处理时间时态表联接使用处理时间属性将行与外部版本表中键的最新版本相关联。
         * 根据定义，对于处理时间属性，联接将始终返回给定键的最新值。可以将查找表看作一个简单的HashMap＜K，V＞，它存储来自构建端的所有记录。
         * 这种联接的强大之处在于，当无法在Flink中将表具体化为动态表时，它允许Flink直接针对外部系统工作。
         *
         *
         * Temporal Table Function Join
         * 时态表函数联接
         * 使用时态表函数联接表的语法与使用表函数联接中的语法相同。
         * 目前只支持带有时态表的内部联接和左外部联接。
         * 假设Rates是一个时态表函数，那么连接可以用SQL表示如下：
         *
         * SELECT
         *   o_amount, r_rate
         * FROM
         *   Orders,
         *   LATERAL TABLE (Rates(o_proctime))
         * WHERE
         *   r_currency = o_currency
         *
         * 时态表DDL与时态表函数的主要区别在于：
         *   1.时态表DDL可以在SQL中定义，但时态表函数不能；
         *   2.时态表DDL和时态表函数都支持时态联接版本的表，但只有时态表函数才能时态联接任何表/视图的最新版本。
         *
         *
         * Lookup Join
         * 查找 JOIN
         * 查找联接通常用于使用从外部系统查询的数据来丰富表。
         * 要求一个表具有处理时间属性，另一个表由查找源连接器支持。
         * 查找联接使用上面的Processing Time Temporal join语法，右表由查找源连接器支持。
         *
         *
         * Orders表扩充MySQL数据库中的Customers表中的数据。
         * 带有后续处理时间属性的FOR SYSTEM_TIME AS OF子句可确保Orders表的每一行在由联接运算符处理Orders行时与那些与联接谓词匹配的Customers行联接。
         * 它还防止将来更新联接的Customer行时更新联接结果。
         * 查找联接还需要强制的相等联接谓词
         *
         *
         * Table Function
         * 将表与表函数的结果连接起来。
         * 左（外部）表的每一行都与表函数的相应调用产生的所有行连接。用户定义的表函数必须在使用前注册。
         *
         * INNER JOIN
         * 如果左（外部）表的表函数调用返回空结果，则删除该行。
         * SELECT order_id, res
         * FROM Orders,
         * LATERAL TABLE(table_func(order_id)) t(res)
         *
         * LEFT OUTER JOIN
         * 如果表函数调用返回空结果，则保留相应的外部行，并用空值填充结果。目前，针对横向表的左外部联接需要ON子句中的TRUE文本。
         *
         * SELECT order_id, res
         * FROM Orders
         * LEFT OUTER JOIN LATERAL TABLE(table_func(order_id)) t(res)
         *   ON TRUE
         *
         */


    }
}
