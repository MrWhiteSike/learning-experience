flink-time-watermark

时间语义和WaterMark


时间语义：
Event Time：事件创建时间
Ingestion Time：数据进入Flink的时间
Processing Time：执行操作算子的本地系统时间，与机器相关

哪种时间语义更重要？
1）不同的时间含义有不同的应用场合
2）我们往往更关心事件时间（Event Time）


设置EventTime
乱序数据的产生：
1）当Flink以Event Time模式处理数据流时，会根据数据里的时间戳来处理基于时间的算子。
2）由于网络、分布式等原因，会导致乱序数据的产生


水印WaterMark
怎样避免乱序数据带来计算不正确？
遇到一个时间戳达到了窗口的关闭时间，不应该立即触发窗口计算，而是等待一段时间，等迟到的数据来了再关闭窗口。

Watermark是一种衡量Event Time进展的机制，可以设定延迟触发。
Watermark是用于处理乱序事件的，而正确的处理乱序事件，通常用Watermark机制结合window来实现；
数据流中的Watermark用于表示timestamp小于Watermark的数据，
都已经到到了，因此，window的执行也是由Watermark触发的。

watermark 用来让程序自己平衡延迟和结果正确性。
不能太大，也不能太小，这需要根据场景去平衡。

类似于把时钟拨慢了

窗口 对应一个 数据桶；

如果不设置watermark延迟时间，那么就是
事件时间 >= 窗口结束时间  时，就会触发窗口的计算
1、watermark，设置一个延迟时间 t1，一般是毫秒级/秒级 
当事件时间 >= 窗口结束时间 + t1 时，才会触发窗口的计算
2、允许延迟一段时间，再次设置一个延迟时间 t2，一般是秒级/分钟/小时级
在此延迟时间段内，来一条数据触发一次窗口计算
当事件时间 >= 窗口结束时间 + t1 + t2 时，才会触发窗口的关闭
3、侧输出流，乱序数据的兜底操作
三种方式去处理延迟数据，保证数据的正确性



WaterMark的传递、引入和设定
从上游向下游进行传递，如果不更新，就不会往下广播
如果有多个WaterMark，取最小值

Watermark的设定：
在Flink中，watermark由应用程序开发人员生成，通常需要对应的领域有一定了解。

如果watermark设置的延迟太久，收到结果的速度可能就会很慢，解决办法是在水印到达之前输出一个近似结果。

如果watermark到达得太早，则可能收到错误结果，不过Flink处理迟到数据的机制可以解决这个问题。


周期性watermark ：适用于数据稠密的场景
间隔性Watermark ：适用于数据稀疏的场景














