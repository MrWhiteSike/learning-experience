hive-query

全表和特定列查询：

注意：
1、sql语言大小写不敏感
2、SQL可以写在一行或者多行
3、关键字不能被缩写也不能分行
4、各子句一般要分行写
5、使用缩进提高语句的可读性。


列别名：
重命名一个列
便于计算
紧跟列名，也可以在列名和别名之前加入关键字 as




算术运算符：
a+b 相加
a-b 减法
a*b 乘法
a/b 除法
a%b 取余
a&b 按位与
a|b 按位或
a^b 按位异或
~a 取反



常用函数：
count：求总行数
max：求最大值
min：求最小值
sum：求总和
avg：求平均


limit语句：
查询返回多行数据，用于限制返回的行数。
limit 5


where语句：
使用where子句，将不满足条件的行进行过滤掉
where子句紧跟from子句
注意：where子句不能使用字段别名。
执行顺序：from -> where -> select


比较运算符：
a=b  a等于b返回true，反之返回false
a<=>b  a和b都为null，返回true，如果一边为null，返回false
a<>b, a!=b a或者b为null，返回null；如果a不等于b，则返回true，反之返回false
a<b a或者b为null，则返回null；如果a小于b，则返回true，反之返回false
a<=b a或者b为null，则返回null；如果a小于等于b，则返回true，反之返回false
a>b a或者b为null，则返回null；如果a大于b，则返回true，反之返回false
a>=b a或者b为null，则返回null；如果a大于等于b，则返回true，反之返回false
a [not] between b and c 如果a，b，c任一个为null，则结果为null。
如果a的值大于等于b而且小于等于c，则结果为true，反之false。
如果使用not关键字则可达到相反的效果。
a is null：判断是否为null

a is not null : 如果a不等于Null，则返回true，反之返回false
in (val1, val2,...)

Like 和 Rlike：
使用Like运算符选择类似的值：
选择条件可以包含字符或者数字
% 代表零个或者多个字符（任意个字符）
_代表一个字符

a [not] like b: 仅字符串类型适用
 b是一个SQL下的简单正则表达式，也叫通配符模式，如果a与其匹配的话，则返回true；反之返回false。b的表达式说明如下： 'x%' 表示a必须以字母x开头，'%x'表示a必须以字母'x'结尾；
'%x%'表示a包含字母x，可以位于开头，结尾或者字符串中间。如果使用not关键字则可达到相反的效果。

a rlike b, a regexp b: 适用于字符串类型
b是基于Java的正则表达式，如果a与其匹配，则返回true；反之返回false。匹配使用的是jdk中的正则表达式接口。



逻辑运算符：
and ： 逻辑并
or：逻辑或
not：逻辑否



分组：
group by语句

group by语句通常会和聚合函数一起使用，按照一个或者多个队列结果进行分组，然后对每个组执行聚合操作。


having 语句：

having 与 where 不同点：
	1）where后面不能写分组函数，而having 后面可以使用分组函数
	2）having只用于group by分组统计语句。

例子：
select name from table group by name having min(fenshu) >= 80; 




Join 语句：
1.等值join
2.表的别名
3.内连接
select 
	e.empno,
	e.ename,
	e.deptno,
	d.dname
from 
	emp e
join 
	dept d 
on e.deptNo = d.deptNo;
4.左外连接
select 
	e.empno,
	e.ename,
	e.deptno,
	d.dname
from 
	emp e
left join 
	dept d 
on e.deptNo = d.deptNo;
5.右外连接
select 
	e.empno,
	e.ename,
	d.deptno,
	d.dname
from 
	emp e
right join 
	dept d 
on e.deptNo = d.deptNo;
6.满外连接、全外连接
使用nvl(,)函数实现前一个为null，使用后一个；后一个为null，使用前一个；

select 
	e.empno,
	e.ename,
	nvl(e.deptno,d.deptNo),
	d.dname
from 
	emp e
full join 
	dept d 
on e.deptNo = d.deptNo;

7.多表连接

8.笛卡尔积
	1）省略连接条件
	2）连接条件无效
	3）所有表中的所有行互相连接

9.左表差集
方式1：通过from a left join b on a.field1 = b.field1 where b.field1 is null;
select 
	e.empno,
	e.ename,
	e.deptno,
	d.dname
from 
	emp e
left join 
	dept d 
on e.deptNo = d.deptNo
where d.deptNo is null;
方式2：通过子查询的方式
select
	e.empno,
	e.ename,
	e.deptno
from
	emp e
where e.deptNo not in 
	(
		select deptNo from dept
		)


10.右表差集
方式1：
select
	d.deptno,
	d.dname
from 
	emp e
right join 
	dept d 
on e.deptNo = d.deptNo
where e.deptNo is null;


方式2：
select
	d.deptno,
	d.dname
from 
	dept d
where d.deptNo not in 
	(select deptNo from emp);

11.左表差集和右表差集；或者说是全连接去除中间重复部分
方式1：
select 
	e.empno,
	e.ename,
	nvl(e.deptno,d.deptNo),
	d.dname
from 
	emp e
full join 
	dept d 
on e.deptNo = d.deptNo;
where e.deptNo is null or d.deptNo is null;

方式2：union连接两张表，两张表的字段必须相同

union 会去重
union all ： 不去重
需求本身不存在重复数据，使用union，union all效果相同，使用union all，效率更高。


select 
	* 
from
(select 
	e.empno,
	e.ename,
	e.deptno as eno,
	d.deptno as dno,
	d.dname
from 
	emp e
left join 
	dept d 
on e.deptNo = d.deptNo
union all
select 
	e.empno,
	e.ename,
	e.deptno as eno,
	d.deptno as dno,
	d.dname
from 
	emp e
right join 
	dept d 
on e.deptNo = d.deptNo) tmp;




order by语句：
order by ： 全局排序，只有一个reducer
asc：升序默认
desc：降序

order by 子句在 select 语句结尾


sort by ： 分区内排序

distribute by： 在有些情况下，我们需要控制某个特定行应该到哪个reducer
通常是为了进行后续的聚集操作。
类似于mr中的partition 进行分区（自定义分区），结合sort by使用。

一定要分配多个reduce进行处理，否则无法看到distribute by的效果。


cluster by：
当distribute by和sort by字段相同时，可以使用cluster by方式。
cluster by除了具有distribute by 的功能还具有sort by的功能。但是
排序只能是升序排序。不能指定排序规则为asc 或者desc。





分区表和分区桶：
分区表(partitioned by)
实际上就是对应一个hdfs文件系统上独立的文件夹，该文件夹下是该
分区所有的数据文件。
Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。
在查询时通过where子句中的表达式选择查询所需要的指定分区。这样的查询效率会提高很多。

创建分区表：
例子，
create table dept_par(deptno int, dname string, loc string)
partitioned by (day string)
row format delimited fields terminated by '\t';

分区表就是为了提高查询效率的，不会进行全表扫描，只会根据指定分区的目录下的数据进行扫描。
注意：where 子句中表达式选择需要指定分区；

增加分区：
单个分区
alter table dept_par add partition(day='20200506');
多个分区
alter table dept_par add partition(day='20200507') partition(day='20200508');


删除分区：
单个分区
alter table dept_par drop partition(day='20200506');
多个分区
alter table dept_par drop partition(day="20200507"),partition(day='20200508');

查看分区表的分区：
show partitions dept_par;

查看分区表的结构：
desc formatted dept_par;


二级分区： 
create table dept_par2(deptno int, dname string, loc string)
partitioned by (day string,hour string)
row format delimited fields terminated by '\t';


修复分区：
方式1：put 数据后，再修复
msck repair table dept_par;

方式2：添加分区
alter table dept_par add partition(day='20200908',hour="14")


方式3：创建文件夹后load数据到分区
load data local inpath '' into table dept_par2 partition(day='20200506',hour='23');


动态分区：
1.开启动态分区功能默认true，开启
hive.exec.dynamic.partition=true
2.设置为非严格模式，动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。
设置属性hive.exec.dynamic.partition.mode=nonstrict
3.在所有mr的节点上，最大一共可以创建多少个动态分区，默认1000
hive.exec.dynamic.partitions=1000
4.在每个执行mr的节点上，最大可以创建多少个动态分区。
该参数需要根据实际的数据来指定。比如，数据中包含了一年的数据
即day字段有365个值，那么该参数就需要设置成365，如果使用默认值100，则会报错。
hive.exec.max.dynamic.partitions.pernode=100
5.整个mrjob中，最大可以创建多少个hdfs文件，默认100000
hive.exec.max.created.files=100000
6.当有空分区生成时，是否抛出异常。一般不需要设置，默认false
hive.error.on.empty.partition=false

默认最后一个字段为分区字段
insert into table dept_par2 partition(deptno)
select dname,loc,deptno from dept;
hive3中的新功能：
insert into table dept_par2
select dname,loc,deptno from dept;



分桶表：
分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据
数据集都可以形成合理的分区对于一张表或者分区，hive可以进一步
组织成桶，也就是更为细粒度的数据范围划分。

分桶是将数据集分解成更容易管理的若干部分的另一个技术。
分区针对的是数据的存储路径；分桶针对的是数据文件。

分区表的字段单独定义
分桶表的字段使用定义中的字段

建表语句：
create table stu_buck(id int, name string)
cluster by(id) --指定分桶字段
into 4 buckets -- 指定分桶个数
row format delimited fields terminated by '\t';
查看表结构：
desc formatted stu_buck;

导入数据到分通表，load方式：
load data inpath '' into table stu_buck;

分桶规则：
hive的分桶采用对分桶字段的值进行hash，然后除以桶的个数取余的
方式决定该条记录存放哪个桶当中。

分桶表操作的注意事项：
1.reduce 个数设置为-1，让job自行决定需要用多少个reduce或者
将reduce个数设置为大于等于分桶表的桶数。
2.从hdfs中load数据到分桶表中，避免本地文件找不到问题
3.不要使用本地模式

insert 方式将数据导入分桶表：
	insert into table stu_buck select * from student;


抽样查询：
对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是
全部结果。
hive可以通过对表进行抽样来满足这个需求。
语法：tablesample(bucket x out of y)

select * from stu_buck tablesample(bucket 1 out of 4 on id);

注意：x的值必须小于等于y的值，否则报错。




函数：

三种：
udf 一进一出
udaf 多进一出
udtf 一进多出

多：指输入数据的行数

1.查看系统自带函数
show functions;

2.显示自带函数的用法
desc function upper;

3.详细显示自带的函数用法
desc function extended upper;

常用的内置函数：
1.空字段赋值
	nvl，给值为null的数据赋值，
	格式：nvl（value，default_value）
	功能：如果value为null，则nvl函数返回default_value的值。否则返回value
注意：default_value可以写死，也可以写一个字段；


2.case when then else end


name dept_id 	sex 
张三 	A 	  	男
李四		A 		男
王五 	B 		男
凤姐 	A 		女
御姐 	B 		女
萝莉 	B 		女

需求：求出不同部门男女各多少人，结果如下：
dept_id 男 女
A       2  1
B       1  2
方式1：case语句，适用于多个分支
select 
	dept_id
	sum(case sex when '男' then 1 else 0 end) maleCount,
	sum(case sex when '女' then 1 else 0 end) femaleCount
from
	emp_sex
group by dept_id;

方式2：if语句，只用两个分支
select 
	dept_id
	sum(if(sex='男',1,0)) maleCount,
	sum(if(sex='女',1,0)) femaleCount
from
	emp_sex
group by dept_id;



3.行转列

4.列转行

5.窗口函数（开窗函数）

6.rank

7.其他常用函数

















